TIL (Today I Learned)

📚 공부타입(강의)
￼
JavaScript 알고리즘 & 자료구조 마스터 클래스

📖 공부내용
* Section 3 - 배열과 오브젝트의 성능 평가
* Section 4 - 문제 해결 접근법

220421 | ccamanglab





오늘도 어제에 이어서 섹션3과 섹션4를 수강했다. 이어서 빠른 시간 내에 섹션 5와 6까지 수강할 계획인데 내용이 길어져서 우선 섹션 4의 내용까지 작성해본다.

📖 공부한 내용
Array & Object | How to access problem solving

📚 3.배열과 오브젝트의 성능 평가


🖊 3.1 섹션 소개

이 섹션은 앞서 배운 빅오 표기법 [시간과 공간 복잡성 코드 성능 분석] 에서 배운 내용을 토대로 이미 알고 있는 지식에 적용하는 것이다.
가장 기본적인 js 에 대해 이야기 때문에 기본적인 js를 알아야하는데, 다행이 진짜 기본적으로 알고 있다.

이번 섹션은

1. 빅오의 시점에서 데이터 입력에 더 빠른 방법이 있고 느린 방법이 있는지?
2. 왜 배열앞에 데이터를 추가하는 것이 좋지 않은지?
3. 더 좋은 방법이 있는지 대안을 보고 내장되어있는 메소드 들을 활용해서 사용해볼텐지?

가 중점적이다.


🖊 3.2 객체의 빅오

객체의 빅오의 특징

- 객체는 정렬이 필요없을 때 사용하면 편리하다.
- 빠른 접근, 입력, 제거를 원할때 좋다.
- 정렬은 안되어있지만 다른것들 모두 빠름

- [삽입] : O(1)
- [제거] : O(1)
- [검색] : O(N)
- [접근] : O(1)

- 유일하게 검색을 하는데 있어서만 선형이며, 다연 오브젝트의 속성이 많을수록 탐색 시간도 늘어난다.

하지만 탐색은 선형이다.
오브젝트의 속성이 많을수록 그 탐색하는 시간도 늘어나는 것이다


🖊 3.3 배열안의 데이터에 대한 접근이 느린 이유

객체에 비해서 배열은

- 순서가 필요할때 사용하지만,
- 입력과 제거를 할때는 되려 시간을 뺏길수도 있다.

배열에서 원하는 값을 찾기 위해 순서를 제공해주면, 그 순서를 찾기 위해 모든 요소를 찾는 것이 아닌, 그로 가는 지름길이 있기 때문에 접근 자체는 상수의 시간값을 가진다.

하지만 아래와 같은 상황에서의 빅 오는 달라진다.

1. 단순 추가 입력 => 객체에 추가하는 것 처럼 단순 상수임.
2. ⭐️ 배열 앞에 추가할 때  => 각각의 인덱스를 새로 배정해서 추가를 진행한다. => O(N) 엘리먼트 마다 작업을 하나씩 해줘야함.
3. ⭐️ 배열 앞에서 제거하는 것도 똑같은 문제임 => O(N)

즉 push() & pop() 이 shift() & unshift() 보다 보통 빠르다. (비어있는 배열일때를 제외하고)


🖊 3.4 빅오 배열 메소드

암기할 필요는 없음. 빅 오 표기 관점에서 이 숫자들이 어떻게 나오는지 이해가 필요함.

각 메소드에 대한 빅 오 정리

* push - O(1)
* pop - O(1)
* shift - O(N)
* unshift - O(N)
* concat - O(N)
* slice - O(N)
* splice - O(N)
* sort - O(N*log(N))
* forEach/map/filter/reduce/etc. - O(N)

일반적으로 배열과 관련된것들은 O(N)이다.

따라서 객체와 배열을 봤을 때 가장 중요한 점은

1. 객체는 거의 모든것을 더 빠르게 하지만 정렬한다는 것.
2. 배열은 정리되어있지만, 객체가 시작에 끝 혹은 중간에 엘리먼트를 추가하고 제거하는것보다 빠르다.(객체에는 순서가 없으니까!)


📚 4.문제 해결 접근법


🖊 4.1 문제 해결법 소개

문제해결에 대한 내용은 너무 방대한 내용이라 5단원에 이어서 설명이 온다고 한다.
두 단원 모두 알고리즘, 문제해결패턴 또는 전략 계획 접근 방식과 관련되어있으며, 어떤 단계를 활용해서 문제를 풀지에 대한 내용이다.

1. 해결법을 모르는 문제를 풀기 위한 방식 접근
2. 많은 문제를 해결할 특정상황에 응용할수있는 구체적인 전략 을 알게된다.

여기서 기초적인 알고리즘에 대한 내용이 나온다.

🖇 알고리즘이란 ? : 현재 보편적인 유행어처럼 여겨지고 있다.

특정 작업을 달성하기 위한 과정이나 일련의 단계를 의미
=> 문제해결을 위해 수행해야하는 일련의 수학적단계

🖇 왜 알아야 할까? : 프로그래밍에서 수행하는 모든 작업에 아주 기본적으로 필요한 내용이다. 근본이다.

이렇게 중요하지만 이 수업에서는 알고리즘의 범위를 줄여서
면접에 나오는 것들에 초점을 두고 하려고 한다.

🖇 어떻게 해야 알고리즘을 이해를 잘 할까?

선천적으로 두뇌가 좋은 사람들이 잘할순있지만, 그걸로 어려움을 겪을 필요가 없음.

그렇다면 알고리즘 능력을 어떻게 향상시킬 수 있을까?

1. 문제해결을 위한 계획을 수립하는 것이다.
2. 일반적인 문제 해결 패턴을 파악하는 것이다

그래서 이번 섹션에서는 문제 해결을 위한 계획을 수립하는 방법을 배운다.

⛰ 문제해결을 하는 단계

1.문제 이해하기
2.구체적인 예시알기
3.세부분석
4.해결 단순화하고
5.문제를 복습하고 되돌아 본다.

이제부터 이 내용들을 학습할 것임.


🖊 4.2 1단계 : 문제의 이해

구문을 배우는 것은 쉽지만, 알고리즘을 하는것은 그것보다 조금 더 높은 단계다.

1. 문제를 나의 방식으로 생각해볼수 있는가?
2. 어떤 입력값을 담고 있는지 이해? (소수점 부동소수점? 숫자의 자릿수? 정수인지? 이런것들)
3. 어떤 출력값이 나와야하는지? 어떤 형태여야하는지? (input과 같은 고민을 한다.)
4. 입력값이 출력값을 결정할 수 있는가? => 입력값을 알고있다면 해당 정보만 사용해서도 괜찮은가? //대부분은 그런데 한숫자만 주어지거나 정보값이 적다면?
5. 데이터의 중요한 부분에 어떻게 라벨을 정할것인가?


🖊 4.3 2단계 : 구체적 예제들

문제를 이해했다면 예시를 떠올려야한다.
최종 해결책을 입력했다면 제대로 작동하는지 검사를 해본다.

입력되는 값으로는

유저 스토리(사용자 입력값)
단위검사의 값

이 존재한다.
(이 부분은 번역이 이렇게 되서 그냥 적었는데, 아무래도 유저 스토리는 유저 입력값(문제풀때 주는값)을 말하고, 단위 검사의 값은 내가 직접 지정해보는 값을 의미하는 것 같다)

단위 검사의 값을 만들기 위해선

1. 작은 예시로 시작을 하기
2. 그다음 조금 복잡한 것을 진행
3. 빈 입력값 생각
4. 유효하지 않은 입력값 생각

의 과정을 거친다.


🖊 4.4 3단계 : 세부 분석

break down이라고도 하는데, 여기서 강사분께서
"허허 브레이크 다운이라고 면접장에서 브레이크 댄스를 추는건 아니에요" 허허허 라고 말함
나촴

이 단계에서는 실제 수행할 코드를 작성해보는데,
굳이 꼭 맞는 코드를 작성한다기보다 내가 세워놓은 이해와 예제들을 통해 수행 작업과 소통을 한다고 생각해야한다.
그러면서 밟아야할 단계를 아주 기본적인 구성요소들을 작성하는 것이다.

그리고나서 확신이 들면 코드를 작성하면 된다.

예시로는 문자열을 취하고 문자열의 각 문자 수를 반환하는 함수를 만드는 상황을 가정해보았다.

🖊 4.5 4단계 : 해결 또는 단순화

문제를 아무런 준비 없이 푼다면,

1.갑작스럽게 문제를 해결하려고 하면 어려운부분에서 막혀서 진도를 나가지 못한다.
어려운 부분이 있더라도 그 부분을 통합 할 수 있는 것을 염두에 두고 코드를 작성하는 것이 좋음.

2.그리고 사실 문제를 이해하고 단순화하는데서 문제가 이미 풀리기 시작하고있다.

만약 루프 구문에 어려움을 느낀다면 하드코딩으로 시작하는 것이 좋은데,
알고리즘에 있어 키와 값을 이용해서 객체를 사용하는데 익숙하다면 문제 해결에 더 도움될것이다.


🖊 4.6 5단계 : 되돌아보기와 리팩터(Refactor)

더 향상된 개발자가 되는데 있어 가장 중요한 단계다.
코드가 아름다울그런 필요는 아니지만 제대로 작동하는게 아주 중요함.
구성요소를 보면서 코드를 다시 보는게 중요함 그리고 중요하게 볼건 [효율성 | 가독성] 두 기둥사이의 균형을 맞추는 것이다.

예를들어

i를 사용하지않고 for of로 고칠수도 있음.
|| 와 같은 정규 표현식 사용 등이 있는데,
사실 정규표현식은 사용중인 브라우저나 상황에따라서 달라질수도 있기 때문에, 내가 그것을 왜 썼고 왜 그런 결과가 나오는지도 알고 있어야한다.(면접에서의 중요 포인트)


🧢 Recap

문제를 해결하기 위한 접근법은 

1. 문제를 이해하기
2. 구체적인 예시 살펴보기
3. 세분화 하기
4. 해결 또는 단순화
5. Look Back & Refactor

결국 제목 자체가 그 해결법들이다.


📍P.S.
항상 알고리즘 문제를 풀면서 위와 비슷한 과정들을 거쳐서 해왔는데, 조금 더 그 과정을 어떻게 세분화 해야할지 감을 잡을 수 있었다.
특히나 리팩터링 하는 과정에서 "당연히 es6 정규 표현식을 사용하는게 무조건 좋지 않을까?" 라는 나의 생각이 조금 잘못된 것도 알수 있었고,
이제는 코드를 짠 후 되돌아보며 시간과 공간의 복잡도를 어떻게 판별하는지에 대한 정확한 이해가 가능할 것 같다.
그리고 인스타 2200자가 최대인걸 오늘 처음 알았당…


